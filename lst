     1                                  BITS 16
     2                                  CPU 8086
     3
     4                                  ;; CONSTANTS
     5
     6                                  ;; Boot sector load address
     7                                  %assign BootSector.Begin 0x7c00
     8                                  %assign BootSector.Size 512
     9                                  %assign BootSector.End BootSector.Begin + BootSector.Size
    10
    11                                  %assign WordSize 2
    12
    13                                  ;; Width and Height apply to both the screen (in text coordinates) and the
    14                                  ;; minefield
    15                                  %assign Width 40
    16                                  %assign Height 25
    17
    18                                  ;; GLOBAL VARIABLES
    19
    20                                  ;; TODO: Change global vars to a state struct
    21
    22                                  ;; Global variables are stored after the boot sector at runtime. After the boot
    23                                  ;; sector, there is 480.5K of memory safe to use.
    24                                  ;; https://wiki.osdev.org/Memory_Map_(x86)#Overview
    25
    26                                  %assign Vars.Begin BootSector.End
    27
    28                                  %assign Map.Size Width * Height
    29                                  ;; TODO: Document these
    30                                  %assign Map.Mines Vars.Begin
    31                                  %assign Map.Unveiled Map.Mines + Map.Size
    32                                  %assign Map.Displayed Map.Unveiled + Map.Size
    33
    34                                  ;; Distance between Map.Mines and Map.Unveiled
    35                                  %assign Map.Mines.ToUnveiled (Map.Unveiled - Map.Mines)
    36
    37                                  ;; Seed used for random number generation
    38                                  %assign RandomSeed Map.Displayed + Map.Size
    39
    40                                  %assign Vars.End RandomSeed + WordSize
    41
    42                                  %assign Vars.Size Vars.End - Vars.Begin
    43
    44                                  org BootSector.Begin
    45
    46                                  Entry:
    47                                    ; VGA text mode 0x00
    48                                    ; 320x200 pixel resolution
    49                                    ; 40x25 text resolution
    50                                    ; 16 colors
    51                                    ; http://www.ctyme.com/intr/rb-0069.htm
    52 00000000 31C0                      xor ax, ax
    53 00000002 CD10                      int 0x10
    54
    55                                    ; Store number of clock ticks since midnight in CX:DX
    56                                    ; http://www.ctyme.com/intr/rb-2271.htm
    57 00000004 31C0                      xor ax, ax
    58 00000006 CD1A                      int 0x1a
    59
    60                                    ; TODO: Remove hard-coded seed
    61 00000008 BA3930                    mov dx, 12345
    62
    63                                    ; Seed the RNG with the amount of ticks
    64 0000000B 8916B889                  mov [RandomSeed], dx
    65
    66                                  ;; Populate Map.Mines with mines
    67                                  PopulateMines:
    68 0000000F BF007E                    mov di, Map.Mines
    69 00000012 B9E803                    mov cx, Map.Size
  70                                  .Loop:
    71                                    ; ax = Rand() & 0b111 ? 0 : 1
    72 00000015 E8B800                    call Rand
    73 00000018 A90700                    test ax, 0b111
    74 0000001B 7404                      jz .Mine
    75                                  .Empty:
    76 0000001D 31C0                      xor ax, ax
    77 0000001F EB03                      jmp .WriteCell
    78                                  .Mine:
    79 00000021 B80100                    mov ax, 1
    80                                  .WriteCell:
    81 00000024 AA                        stosb
    82 00000025 E2EE                      loop .Loop
    83
    84                                  ;; Number empty cells with amount of neighboring mines
    85                                  NumCells:
  86 00000027 BFE881                    mov di, Map.Unveiled
    87 0000002A B9E803                    mov cx, Map.Size
    88                                  .Loop:
    89                                    ; Get digit for the cell at DI
    90 0000002D 8B8518FC                  mov ax, [di - Map.Mines.ToUnveiled]
    91 00000031 85C0                      test ax, ax
    92 00000033 7405                      jz .Empty
    93                                  .Mine:
    94 00000035 B82A00                    mov ax, '*'
    95 00000038 EB43                      jmp .WriteCell
    96                                  .Empty:
    97 0000003A B83000                    mov ax, '0'
    98
    99                                    ; Straight
   100 0000003D 8D9D17FC                  lea bx, [di - 1 - Map.Mines.ToUnveiled]
   101 00000041 E84D00                    call LeftIncIfMineAtCell
   102 00000044 8D9D19FC                  lea bx, [di + 1 - Map.Mines.ToUnveiled]
   103 00000048 E85E00                    call RightIncIfMineAtCell
   104 0000004B 8D9DF0FB                  lea bx, [di - Width - Map.Mines.ToUnveiled]
   105 0000004F E86E00                    call IncIfMineAtCell
   106 00000052 8D9D40FC                  lea bx, [di + Width - Map.Mines.ToUnveiled]
   107 00000056 E86700                    call IncIfMineAtCell
   108
   109                                    ; Diagonal
   110 00000059 8D9DEFFB                  lea bx, [di - 1 - Width - Map.Mines.ToUnveiled]
   111 0000005D E83100                    call LeftIncIfMineAtCell
   112 00000060 8D9D3FFC                  lea bx, [di - 1 + Width - Map.Mines.ToUnveiled]
   113 00000064 E82A00                    call LeftIncIfMineAtCell
   114 00000067 8D9DF1FB                  lea bx, [di + 1 - Width - Map.Mines.ToUnveiled]
   115 0000006B E83B00                    call RightIncIfMineAtCell
   116 0000006E 8D9D41FC                  lea bx, [di + 1 + Width - Map.Mines.ToUnveiled]
   117 00000072 E83400                    call RightIncIfMineAtCell
   118
   119 00000075 83F830                    cmp ax, '0'
   120 00000078 7503                      jne .WriteCell
   121                                  .Zero:
   122 0000007A B82000                    mov ax, ' '
   123                                  .WriteCell:
   124 0000007D AA                        stosb
   125 0000007E E2AD                      loop .Loop
   126
   127                                  PrintMinefield:
   128 00000080 B9E803                    mov cx, Map.Size
   129 00000083 BDE881                    mov bp, Map.Unveiled
   130 00000086 BB6400                    mov bx, 0x0064
   131 00000089 31D2                      xor dx, dx
   132 0000008B B80013                    mov ax, 0x1300
   133 0000008E CD10                      int 0x10
   134 00000090 F4                        hlt
   135
   136                                  LeftIncIfMineAtCell:
   137 00000091 53                        push bx
   138 00000092 50                        push ax
   139 00000093 52                        push dx
   140 00000094 81EB007E                  sub bx, Map.Mines
   141 00000098 89D8                      mov ax, bx
   142 0000009A 99                        cwd
   143 0000009B BB2800                    mov bx, Width
   144 0000009E F7FB                      idiv bx
   145 000000A0 85D2                      test dx, dx
   146 000000A2 5A                        pop dx
   147 000000A3 58                        pop ax
   148 000000A4 5B                        pop bx
   149 000000A5 7428                      jz IncIfMineAtCell.RetZero
   150 000000A7 EB17                      jmp IncIfMineAtCell
   151                                  RightIncIfMineAtCell:
   152 000000A9 53                        push bx
   153 000000AA 50                        push ax
   154 000000AB 52                        push dx
   155 000000AC 81EB007E                  sub bx, Map.Mines
   156 000000B0 89D8                      mov ax, bx
   157 000000B2 99                        cwd
   158 000000B3 BB2800                    mov bx, Width
   159 000000B6 F7FB                      idiv bx
   160 000000B8 83FA27                    cmp dx, Width - 1
   161 000000BB 5A                        pop dx
   162 000000BC 58                        pop ax
   163 000000BD 5B                        pop bx
   164 000000BE 740F                      je IncIfMineAtCell.RetZero
   165                                  ;; TODO: Update comment
   166                                  ;;
   167                                  ;; Increment AX if there is a mine in Map.Mines at index BX, where BX is a
   168                                  ;; pointer inside Map.Mines. In the case where BX is outside Map.Mines, AX is
   169                                  ;; NOT incremented.
   170                                  ;;
   171                                  ;; Parameters
   172                                  ;;   * BX - Pointer inside Map.Mines
   173                                  ;; Clobbered registers
   174                                  ;;   * AX - either incremented or unchanged, depending on whether there is or
   175                                  ;;          isn't a mine at BX, respectively
   176                                  IncIfMineAtCell:
   177                                    ; Bounds check
   178 000000C0 81FB007E                  cmp bx, Map.Mines
   179 000000C4 7209                      jb .RetZero
   180 000000C6 81FBE881                  cmp bx, Map.Mines + Map.Size
   181 000000CA 7303                      jae .RetZero
   182                                    ; Within map bounds. Dereference and add map pointer.
   183 000000CC 0307                      add ax, [bx]
   184 000000CE C3                        ret
   185                                  .RetZero:
   186                                    ; Outside map bounds. Do not increment.
   187 000000CF C3                        ret
   188
   189                                  ;; Return a random value in AX
   190                                  Rand:
   191                                    ; 16 bit xorshift
   192                                    ;
   193                                    ;   xs ^= xs << 7;
   194                                    ;   xs ^= xs >> 9;
   195                                    ;   xs ^= xs << 8;
   196                                    ;   return xs;
   197                                    ;
   198                                    ; http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
   199 000000D0 53                        push bx
   200 000000D1 51                        push cx
   201 000000D2 A1B889                    mov ax, [RandomSeed]
   202
   203                                    ; ax ^= ax << 7
   204 000000D5 89C3                      mov bx, ax
   205 000000D7 B90700                    mov cx, 7
   206 000000DA D3E3                      shl bx, cl
   207 000000DC 31D8                      xor ax, bx
   208
   209                                    ; ax ^= ax >> 9
   210 000000DE 89C3                      mov bx, ax
   211 000000E0 B90900                    mov cx, 9
   212 000000E3 D3EB                      shr bx, cl
   213 000000E5 31D8                      xor ax, bx
   214
   215                                    ; ax ^= ax << 8
   216 000000E7 89C3                      mov bx, ax
   217 000000E9 B90800                    mov cx, 8
   218 000000EC D3E3                      shl bx, cl
   219 000000EE 31D8                      xor ax, bx
   220
   221 000000F0 A3B889                    mov [RandomSeed], ax
   222 000000F3 59                        pop cx
   223 000000F4 5B                        pop bx
   224 000000F5 C3                        ret
   225
   226                                  HelloWorldStr:
   227 000000F6 48656C6C6F20776F72-       db "Hello world!"
   227 000000FF 6C6421
   228                                    HelloWorldStrLen equ $ - HelloWorldStr
   229
   230                                  ;; Print program size at build time
   231                                  %assign CodeSize $ - $$
   232                                  %warning Code is CodeSize bytes
   232          ******************       warning: Code is 258 bytes [-w+user]
   233
   234                                  CodeEnd:
   235                                    ; Pad to size of boot sector, minus the size of a word for the boot sector
   236                                    ; magic value. If the code is too big to fit in a boot sector, the `times`
   237                                    ; directive uses a negative value, causing a build error.
   238 00000102 00<rept>                  times (BootSector.Size - WordSize) - CodeSize db 0
   239
   240                                    ; Boot sector magic
   241 000001FE 55AA                      dw 0xaa55
   242
   243                                  ;; Boot sector ends here
